/**
 * Hook personnalis√© pour la gestion des r√©glages avec Firebase
 */
import { useState, useEffect, useCallback } from 'react';
import { useAuth } from '../contexts/AuthContext';
import settingsService from '../services/settingsService';

/**
 * Hook pour g√©rer les r√©glages utilisateur avec synchronisation Firebase
 */
export const useSettings = () => {
  const { user, isAuthenticated } = useAuth();
  const [settings, setSettings] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [syncing, setSyncing] = useState(false);
  const [lastSyncTime, setLastSyncTime] = useState(null);

  /**
   * Charger les r√©glages depuis localStorage imm√©diatement
   */
  const loadFromLocalStorage = useCallback(() => {
    try {
      console.log('üì± Chargement depuis localStorage...');
      
      const localSettings = {
        clinicName: localStorage.getItem('clinicName') || '',
        clinicAddress: localStorage.getItem('clinicAddress') || '',
        clinicCurrency: localStorage.getItem('clinicCurrency') || 'EUR',
        clinicLogo: localStorage.getItem('clinicLogo') || '',
        geminiApiKey: localStorage.getItem('geminiApiKey') || '',
        lastApiCheck: localStorage.getItem('lastApiCheck') || null,
        geminiConnectionStatus: localStorage.getItem('geminiConnectionStatus') || null
      };
      
      // V√©rifier si on a des donn√©es en localStorage
      const hasLocalData = Object.values(localSettings).some(value => value && value !== '');
      
      if (hasLocalData) {
        console.log('‚úÖ Donn√©es trouv√©es en localStorage:', localSettings);
        setSettings(localSettings);
        setLoading(false); // Arr√™ter le loading imm√©diatement
        return localSettings;
      } else {
        console.log('üì± Pas de donn√©es en localStorage');
        return null;
      }
    } catch (error) {
      console.error('‚ùå Erreur lecture localStorage:', error);
      return null;
    }
  }, []);

  /**
   * Charger les r√©glages depuis Firebase (synchronisation en arri√®re-plan)
   */
  const loadSettings = useCallback(async () => {
    if (!user) {
      console.log('‚ùå loadSettings: Pas d\'utilisateur');
      return;
    }

    try {
      console.log('üîÑ loadSettings: D√©but du chargement Firebase pour', user.uid.substring(0, 8) + '...');
      setSyncing(true);
      setError(null);
      
      const userSettings = await settingsService.getSettings(user.uid);
      console.log('‚úÖ loadSettings: R√©glages Firebase charg√©s:', userSettings);
      setSettings(userSettings);
      setLastSyncTime(new Date());
      
      // Synchroniser vers localStorage pour la prochaine fois
      settingsService.syncToLocalStorage(userSettings);
      
    } catch (error) {
      console.error('‚ùå loadSettings: Erreur lors du chargement des r√©glages:', error);
      setError(error.message);
      
      // En cas d'erreur Firebase, utiliser les r√©glages par d√©faut seulement si pas de settings
      const currentSettings = settings;
      if (!currentSettings) {
        const defaultSettings = settingsService.getDefaultSettings();
        console.log('üîÑ loadSettings: Utilisation des r√©glages par d√©faut:', defaultSettings);
        setSettings(defaultSettings);
      }
    } finally {
      setSyncing(false);
    }
  }, [user]); // SUPPRIM√â settings des d√©pendances pour √©viter la boucle

  /**
   * Sauvegarder les r√©glages dans Firebase
   */
  const saveSettings = useCallback(async (newSettings) => {
    console.log('üéØ === HOOK useSettings.saveSettings ===');
    console.log('üë§ User:', user ? `${user.uid.substring(0, 8)}...` : 'null');
    console.log('üìù New settings:', newSettings);
    console.log('üìã Current settings:', settings);
    
    if (!user) {
      console.error('‚ùå Utilisateur non connect√©');
      throw new Error('Utilisateur non connect√©');
    }

    try {
      console.log('üîÑ D√©but synchronisation...');
      setSyncing(true);
      setError(null);
      
      // Fusionner avec les r√©glages existants
      const updatedSettings = {
        ...settings,
        ...newSettings
      };
      
      console.log('üîÄ Settings fusionn√©s:', updatedSettings);
      console.log('üíæ Appel settingsService.saveSettings...');
      
      const savedSettings = await settingsService.saveSettings(user.uid, updatedSettings);
      
      console.log('‚úÖ R√©ponse du service:', savedSettings);
      
      // Synchroniser vers localStorage
      settingsService.syncToLocalStorage(savedSettings);
      
      setLastSyncTime(new Date());
      
      console.log('üéØ === FIN HOOK saveSettings ===');
      return savedSettings;
    } catch (error) {
      console.error('‚ùå Erreur lors de la sauvegarde des r√©glages:', error);
      console.error('‚ùå Error details:', error.message, error.code);
      setError(error.message);
      throw error;
    } finally {
      setSyncing(false);
    }
  }, [user, settings]);

  /**
   * Migrer les donn√©es depuis localStorage
   */
  const migrateFromLocalStorage = useCallback(async () => {
    if (!user) {
      throw new Error('Utilisateur non connect√©');
    }

    try {
      setSyncing(true);
      setError(null);
      
      const migratedSettings = await settingsService.migrateFromLocalStorage(user.uid);
      setLastSyncTime(new Date());
      
      return migratedSettings;
    } catch (error) {
      console.error('Erreur lors de la migration:', error);
      setError(error.message);
      throw error;
    } finally {
      setSyncing(false);
    }
  }, [user]);

  /**
   * Forcer la synchronisation
   */
  const forceSync = useCallback(async () => {
    if (!user) return;
    
    try {
      setSyncing(true);
      setError(null);
      
      // Recharger depuis Firebase
      await loadSettings();
      
    } catch (error) {
      console.error('Erreur lors de la synchronisation forc√©e:', error);
      setError(error.message);
    } finally {
      setSyncing(false);
    }
  }, [user, loadSettings]);

  /**
   * R√©initialiser les r√©glages
   */
  const resetSettings = useCallback(async () => {
    if (!user) {
      throw new Error('Utilisateur non connect√©');
    }

    try {
      setSyncing(true);
      setError(null);
      
      const defaultSettings = settingsService.getDefaultSettings();
      const resetSettings = await settingsService.saveSettings(user.uid, defaultSettings);
      
      // Nettoyer localStorage
      localStorage.removeItem('clinicName');
      localStorage.removeItem('clinicAddress');
      localStorage.removeItem('clinicCurrency');
      localStorage.removeItem('clinicLogo');
      localStorage.removeItem('geminiApiKey');
      
      setLastSyncTime(new Date());
      
      return resetSettings;
    } catch (error) {
      console.error('Erreur lors de la r√©initialisation:', error);
      setError(error.message);
      throw error;
    } finally {
      setSyncing(false);
    }
  }, [user]);

  /**
   * Mettre √† jour un r√©glage sp√©cifique
   */
  const updateSetting = useCallback(async (key, value) => {
    return await saveSettings({ [key]: value });
  }, [saveSettings]);

  // Charger imm√©diatement depuis localStorage au montage
  useEffect(() => {
    console.log('üì± useEffect initial - chargement localStorage...');
    const localData = loadFromLocalStorage();
    
    if (!localData) {
      // Pas de donn√©es locales, utiliser les r√©glages par d√©faut
      const defaultSettings = settingsService.getDefaultSettings();
      setSettings(defaultSettings);
      setLoading(false);
    }
  }, [loadFromLocalStorage]);

  // Synchroniser avec Firebase quand l'utilisateur est connect√© (UNE SEULE FOIS)
  useEffect(() => {
    console.log('üîÑ useEffect Firebase sync - isAuthenticated:', isAuthenticated, 'user:', !!user);
    
    if (isAuthenticated && user) {
      console.log('‚úÖ Utilisateur connect√© - synchronisation Firebase...');
      loadSettings(); // Synchronisation en arri√®re-plan UNE SEULE FOIS
    } else if (!isAuthenticated && !user) {
      console.log('‚ùå Non authentifi√© - garder les donn√©es locales');
      // Ne pas r√©initialiser settings, garder les donn√©es localStorage
    } else {
      console.log('‚è≥ En attente d\'authentification...');
    }
  }, [isAuthenticated, user]); // SUPPRIM√â loadSettings des d√©pendances

  // √âcouter les changements en temps r√©el
  useEffect(() => {
    if (!user || !isAuthenticated) {
      console.log('üî• Pas d\'√©coute temps r√©el - user:', !!user, 'isAuthenticated:', isAuthenticated);
      return;
    }

    console.log('üî• D√©marrage de l\'√©coute temps r√©el des r√©glages pour:', user.uid.substring(0, 8) + '...');
    
    const unsubscribe = settingsService.subscribeToSettings(
      user.uid,
      (newSettings) => {
        console.log('üî• R√©glages mis √† jour en temps r√©el:', newSettings);
        
        // √âviter les mises √† jour inutiles qui causent des boucles
        setSettings(currentSettings => {
          // Comparer les donn√©es importantes (sans les timestamps)
          const currentData = currentSettings ? {
            clinicName: currentSettings.clinicName,
            clinicAddress: currentSettings.clinicAddress,
            clinicCurrency: currentSettings.clinicCurrency,
            clinicLogo: currentSettings.clinicLogo,
            geminiApiKey: currentSettings.geminiApiKey
          } : null;
          
          const newData = {
            clinicName: newSettings.clinicName,
            clinicAddress: newSettings.clinicAddress,
            clinicCurrency: newSettings.clinicCurrency,
            clinicLogo: newSettings.clinicLogo,
            geminiApiKey: newSettings.geminiApiKey
          };
          
          // Seulement mettre √† jour si les donn√©es ont vraiment chang√©
          if (JSON.stringify(currentData) !== JSON.stringify(newData)) {
            console.log('üî• Donn√©es diff√©rentes - mise √† jour');
            setLoading(false);
            setError(null);
            setLastSyncTime(new Date());
            
            // Synchroniser vers localStorage
            settingsService.syncToLocalStorage(newSettings);
            
            return newSettings;
          } else {
            console.log('üî• Donn√©es identiques - pas de mise √† jour');
            return currentSettings;
          }
        });
      }
    );

    return () => {
      console.log('üî• Arr√™t de l\'√©coute temps r√©el des r√©glages');
      unsubscribe();
    };
  }, [user, isAuthenticated]);

  /**
   * Obtenir le r√©sum√© des r√©glages
   */
  const getSettingsSummary = useCallback(() => {
    return settingsService.getSettingsSummary(settings);
  }, [settings]);

  /**
   * V√©rifier si les r√©glages sont configur√©s
   */
  const isConfigured = useCallback(() => {
    return settingsService.isConfigured(settings);
  }, [settings]);

  return {
    // √âtat
    settings,
    loading,
    error,
    syncing,
    lastSyncTime,
    
    // Propri√©t√©s calcul√©es
    isReady: !loading && settings !== null && isAuthenticated,
    isConfigured: isConfigured(),
    summary: getSettingsSummary(),
    
    // Actions
    saveSettings,
    updateSetting,
    migrateFromLocalStorage,
    forceSync,
    resetSettings,
    
    // Utilitaires
    clearError: () => setError(null),
    
    // Statut de synchronisation
    syncStatus: {
      syncing,
      lastSync: lastSyncTime,
      hasError: !!error,
      isOnline: isAuthenticated
    }
  };
};

/**
 * Hook pour un r√©glage sp√©cifique
 */
export const useSetting = (key, defaultValue = '') => {
  const { settings, updateSetting, loading, syncing } = useSettings();
  
  const value = settings?.[key] ?? defaultValue;
  
  const setValue = useCallback(async (newValue) => {
    return await updateSetting(key, newValue);
  }, [key, updateSetting]);
  
  return [value, setValue, { loading, syncing }];
};

/**
 * Hook pour les r√©glages de la clinique
 */
export const useClinicSettings = () => {
  const { settings, saveSettings, loading, syncing } = useSettings();
  
  const clinicSettings = {
    name: settings?.clinicName || '',
    address: settings?.clinicAddress || '',
    currency: settings?.clinicCurrency || 'EUR',
    logo: settings?.clinicLogo || ''
  };
  
  const updateClinicSettings = useCallback(async (newClinicSettings) => {
    return await saveSettings({
      clinicName: newClinicSettings.name,
      clinicAddress: newClinicSettings.address,
      clinicCurrency: newClinicSettings.currency,
      clinicLogo: newClinicSettings.logo
    });
  }, [saveSettings]);
  
  return {
    clinicSettings,
    updateClinicSettings,
    loading,
    syncing
  };
};

export default useSettings;